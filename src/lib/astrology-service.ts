// This is an autogenerated file from Firebase Studio.
'use server';
/**
 * @fileOverview A service for performing astrological calculations.
 * This will eventually house the logic for generating Kundli charts
 * using the Swiss Ephemeris library.
 */
import * as swisseph from 'swisseph';

// Promisify the swisseph functions we need
const swe_julday_promise = (
  year: number, month: number, day: number, hour: number, gregflag: number
): Promise<number> => {
  return new Promise((resolve, reject) => {
    swisseph.swe_julday(year, month, day, hour, gregflag, (julday_ut) => {
      if (julday_ut) {
        resolve(julday_ut);
      } else {
        reject('Failed to calculate Julian Day.');
      }
    });
  });
};

const swe_calc_ut_promise = (tjd_ut: number, ipl: number, iflag: number): Promise<any> => {
  return new Promise((resolve, reject) => {
    swisseph.swe_calc_ut(tjd_ut, ipl, iflag, (result) => {
      if (result.return_code === 0) {
        resolve(result);
      } else {
        reject(result.error_message);
      }
    });
  });
};

const swe_houses_promise = (tjd_ut: number, lat: number, lon: number, hsys: string): Promise<any> => {
    return new Promise((resolve, reject) => {
        swisseph.swe_houses(tjd_ut, lat, lon, hsys, (result) => {
            if (result.return_code === 0) {
                resolve(result);
            } else {
                reject(result.error_message);
            }
        });
    });
};

const PLANETS = [
  { id: swisseph.SE_SUN, name: 'Sun' },
  { id: swisseph.SE_MOON, name: 'Moon' },
  { id: swisseph.SE_MERCURY, name: 'Mercury' },
  { id: swisseph.SE_VENUS, name: 'Venus' },
  { id: swisseph.SE_MARS, name: 'Mars' },
  { id: swisseph.SE_JUPITER, name: 'Jupiter' },
  { id: swisseph.SE_SATURN, name: 'Saturn' },
  { id: swisseph.SE_TRUE_NODE, name: 'Rahu' }, // True Node for Rahu
];
const KETU_ID = -1; // Placeholder for Ketu
const ALL_PLANETS_FOR_KUNDLI = [ ...PLANETS, { id: KETU_ID, name: 'Ketu' } ];


const ZODIAC_SIGNS = [
    'Aries', 'Taurus', 'Gemini', 'Cancer', 'Leo', 'Virgo',
    'Libra', 'Scorpio', 'Sagittarius', 'Capricorn', 'Aquarius', 'Pisces'
];

const NAKSHATRA_SPAN = 13.3333333333; // 13 degrees 20 minutes
const NAKSHATRAS = [
    { name: 'Ashwini', lord: 'Ketu' }, { name: 'Bharani', lord: 'Venus' }, { name: 'Krittika', lord: 'Sun' },
    { name: 'Rohini', lord: 'Moon' }, { name: 'Mrigashira', lord: 'Mars' }, { name: 'Ardra', lord: 'Rahu' },
    { name: 'Punarvasu', lord: 'Jupiter' }, { name: 'Pushya', lord: 'Saturn' }, { name: 'Ashlesha', lord: 'Mercury' },
    { name: 'Magha', lord: 'Ketu' }, { name: 'Purva Phalguni', lord: 'Venus' }, { name: 'Uttara Phalguni', lord: 'Sun' },
    { name: 'Hasta', lord: 'Moon' }, { name: 'Chitra', lord: 'Mars' }, { name: 'Swati', lord: 'Rahu' },
    { name: 'Vishakha', lord: 'Jupiter' }, { name: 'Anuradha', lord: 'Saturn' }, { name: 'Jyeshtha', lord: 'Mercury' },
    { name: 'Mula', lord: 'Ketu' }, { name: 'Purva Ashadha', lord: 'Venus' }, { name: 'Uttara Ashadha', lord: 'Sun' },
    { name: 'Shravana', lord: 'Moon' }, { name: 'Dhanishta', lord: 'Mars' }, { name: 'Shatabhisha', lord: 'Rahu' },
    { name: 'Purva Bhadrapada', lord: 'Jupiter' }, { name: 'Uttara Bhadrapada', lord: 'Saturn' }, { name: 'Revati', lord: 'Mercury' }
];

const DASHA_LORDS_SEQUENCE = ['Ketu', 'Venus', 'Sun', 'Moon', 'Mars', 'Rahu', 'Jupiter', 'Saturn', 'Mercury'];
const DASHA_DURATIONS: { [key: string]: number } = { 'Ketu': 7, 'Venus': 20, 'Sun': 6, 'Moon': 10, 'Mars': 7, 'Rahu': 18, 'Jupiter': 16, 'Saturn': 19, 'Mercury': 17 };
const TOTAL_DASHA_YEARS = 120;


function getSign(degree: number): string {
    return ZODIAC_SIGNS[Math.floor(degree / 30)];
}

function getHouse(degree: number, houseCusps: number[]): number {
    for (let i = 0; i < 12; i++) {
        const cusp1 = houseCusps[i];
        const cusp2 = (i === 11) ? houseCusps[0] + 360 : houseCusps[i + 1];

        if (cusp1 < cusp2) { // Normal case
            if (degree >= cusp1 && degree < cusp2) {
                return i + 1;
            }
        } else { // Case where house crosses 0 degree Aries
            if (degree >= cusp1 || degree < cusp2) {
                return i + 1;
            }
        }
    }
    return -1; // Should not happen in a valid chart
}

function getNakshatra(longitude: number): { index: number; name: string; lord: string; traversed: number } {
    const nakshatraIndex = Math.floor(longitude / NAKSHATRA_SPAN);
    const nakshatraStart = nakshatraIndex * NAKSHATRA_SPAN;
    const traversed = (longitude - nakshatraStart) / NAKSHATRA_SPAN; // As a percentage
    return {
        index: nakshatraIndex,
        name: NAKSHATRAS[nakshatraIndex].name,
        lord: NAKSHATRAS[nakshatraIndex].lord,
        traversed: parseFloat(traversed.toFixed(4)),
    };
}


interface KundliInput {
    date: Date;
    lat: number;
    lon: number;
}

export interface PlanetData {
    name: string;
    degree: number;
    sign: string;
    house: number;
}

export interface Mahadasha {
    dashaLord: string;
    startDate: string;
    endDate: string;
}

/**
 * Calculates the core Kundli data (planetary positions and ascendant).
 */
export const getKundliData = async ({ date, lat, lon }: KundliInput): Promise<{ascendant: {degree: number, sign: string}, planets: PlanetData[]}> => {
  try {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth() + 1;
    const day = date.getUTCDate();
    const hours = date.getUTCHours();
    const minutes = date.getUTCMinutes();
    const seconds = date.getUTCSeconds();
    const hour_decimal = hours + minutes / 60 + seconds / 3600;

    // Set ephemeris path
    swisseph.swe_set_ephe_path(__dirname + '/../../ephe');

    const julday_ut = await swe_julday_promise(year, month, day, hour_decimal, swisseph.SE_GREG_CAL);

    // Calculate house cusps (including Ascendant)
    const houses = await swe_houses_promise(julday_ut, lat, lon, 'P');
    const houseCusps = houses.house.slice(1); // house[0] is not used
    const ascendantDegree = houseCusps[0];
    
    // Calculate Sidereal positions for planets
    swisseph.swe_set_sid_mode(swisseph.SE_SIDM_LAHIRI, 0, 0);
    const iflag = swisseph.SEFLG_SWIEPH | swisseph.SEFLG_SIDEREAL;

    const planetPositionPromises = PLANETS.map(async (planet) => {
        const pos = await swe_calc_ut_promise(julday_ut, planet.id, iflag);
        return { ...planet, rawPos: pos };
    });
    
    const resolvedPlanetPositions = await Promise.all(planetPositionPromises);

    const rahuPos = resolvedPlanetPositions.find(p => p.name === 'Rahu');
    if (rahuPos) {
        resolvedPlanetPositions.push({
            id: KETU_ID,
            name: 'Ketu',
            rawPos: { longitude: (rahuPos.rawPos.longitude + 180) % 360 }
        });
    }

    const planetPositions = resolvedPlanetPositions.map(p => {
        const degree = p.rawPos.longitude;
        return {
            name: p.name,
            degree: parseFloat(degree.toFixed(2)),
            sign: getSign(degree),
            house: getHouse(degree, houseCusps),
        };
    });
    
    return {
      ascendant: {
        degree: parseFloat(ascendantDegree.toFixed(2)),
        sign: getSign(ascendantDegree)
      },
      planets: planetPositions,
    };

  } catch (error) {
    console.error('Error in getKundliData:', error);
    throw new Error('Failed to calculate Kundli data using Swiss Ephemeris.');
  }
};


/**
 * Calculates astrological doshas and yogas based on planet positions.
 */
export const getVedicYogasAndDoshas = (planets: PlanetData[], ascendantSign: string): { name: string; description: string }[] => {
    const results: { name: string; description: string }[] = [];
    const getPlanet = (name: string) => planets.find(p => p.name === name);

    // Mangal Dosha (Mars in 1, 4, 7, 8, 12th house from Lagna)
    const mars = getPlanet('Mars');
    if (mars) {
        const mangalDoshaHouses = [1, 4, 7, 8, 12];
        if (mangalDoshaHouses.includes(mars.house)) {
            results.push({
                name: "Mangal Dosha",
                description: `Present because Mars is in the ${mars.house}th house from the Ascendant.`
            });
        }
    }

    // Gaj Kesari Yoga (Jupiter in a Kendra [1, 4, 7, 10] from the Moon)
    const jupiter = getPlanet('Jupiter');
    const moon = getPlanet('Moon');
    if (jupiter && moon) {
        const moonHouse = moon.house;
        const jupiterHouse = jupiter.house;
        const relativeHouse = (jupiterHouse - moonHouse + 12) % 12; // 0 for same house, 1 for next etc.
        // Kendra from a house are the 1st, 4th, 7th, 10th houses from it.
        // Relative houses will be 0, 3, 6, 9.
        if ([0, 3, 6, 9].includes(relativeHouse)) {
             results.push({
                name: "Gaj Kesari Yoga",
                description: `Present because Jupiter is in a Kendra house (${(relativeHouse)+1}) from the Moon.`
            });
        }
    }
    
    return results;
};

/**
 * Calculates the Vimshottari Dasha periods.
 */
export const getVimshottariDasha = (moonDegree: number, birthDate: Date): Mahadasha[] => {
    const moonNakshatra = getNakshatra(moonDegree);
    const startingLord = moonNakshatra.lord;
    const lordDuration = DASHA_DURATIONS[startingLord];

    const remainingDashaDuration = lordDuration * (1 - moonNakshatra.traversed);
    
    const dashaPeriods: Mahadasha[] = [];
    let currentLordIndex = DASHA_LORDS_SEQUENCE.indexOf(startingLord);
    let currentDate = new Date(birthDate);

    // Add the first partial Dasha
    const firstDashaEndDate = new Date(currentDate);
    firstDashaEndDate.setFullYear(firstDashaEndDate.getFullYear() + Math.floor(remainingDashaDuration));
    const remainingDays = (remainingDashaDuration % 1) * 365.25;
    firstDashaEndDate.setDate(firstDashaEndDate.getDate() + Math.floor(remainingDays));

    dashaPeriods.push({
        dashaLord: startingLord,
        startDate: currentDate.toISOString().split('T')[0],
        endDate: firstDashaEndDate.toISOString().split('T')[0]
    });

    currentDate = new Date(firstDashaEndDate);

    // Loop for the rest of the 120-year cycle
    for (let i = 1; i < DASHA_LORDS_SEQUENCE.length * 2; i++) { // Loop more to ensure we cover a long lifespan
        currentLordIndex = (currentLordIndex + 1) % DASHA_LORDS_SEQUENCE.length;
        const currentLord = DASHA_LORDS_SEQUENCE[currentLordIndex];
        const duration = DASHA_DURATIONS[currentLord];
        
        const startDate = new Date(currentDate);
        const endDate = new Date(startDate);
        endDate.setFullYear(endDate.getFullYear() + duration);

        dashaPeriods.push({
            dashaLord: currentLord,
            startDate: startDate.toISOString().split('T')[0],
            endDate: endDate.toISOString().split('T')[0]
        });

        currentDate = new Date(endDate);
    }

    return dashaPeriods.slice(0, 12); // Return a reasonable number of dashas
};
